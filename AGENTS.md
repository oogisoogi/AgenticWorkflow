# AgenticWorkflow — AI 에이전트 공통 지시서

> 이 파일은 **모델·도구에 무관하게** 이 프로젝트에서 작업하는 모든 AI 에이전트가 따라야 할 규칙이다.
> Claude Code, Cursor, Copilot, Codex 등 어떤 도구를 사용하든 이 문서의 규칙이 적용된다.

---

## 1. 프로젝트 정의

에이전트 기반 워크플로우 자동화 프로젝트. 복잡한 작업을 체계적 워크플로우로 설계하고, 그 워크플로우를 실제로 구현하여 동작시키는 것이 목적이다.

### 최종 목표 — 2단계 프로세스

| 단계 | 산출물 | 성격 |
|------|--------|------|
| **Phase 1: 워크플로우 설계** | `workflow.md` | 중간 산출물 (설계도) |
| **Phase 2: 워크플로우 구현** | 에이전트·스크립트·자동화가 실제 동작하는 시스템 | **최종 산출물** |

> `workflow.md`를 만드는 것은 절반이다. **그 안에 기술된 내용이 실제로 동작하는 것**이 최종 목표다.

### 워크플로우 기본 구조

모든 워크플로우는 3단계로 구성된다:

1. **Research** — 정보 수집 및 분석
2. **Planning** — 계획 수립, 구조화, 사람의 검토/승인
3. **Implementation** — 실제 실행 및 산출물 생성

각 단계에는 다음을 명시한다:
- 수행 작업 (Task)
- 담당 에이전트
- 데이터 전처리/후처리
- 산출물 (Output)
- 사람 개입 지점 (해당 시)

---

## 2. 절대 기준

> **이 프로젝트의 모든 설계·구현·수정 의사결정에 적용되는 최상위 규칙이다.**
> 아래의 모든 원칙, 가이드라인, 관례보다 상위에 있다.
> 어떤 원칙이든 절대 기준과 충돌하면, 절대 기준이 이긴다.

### 절대 기준 1: 최종 결과물의 품질

> **속도, 토큰 비용, 작업량, 분량 제한은 완전히 무시한다.**
> 모든 의사결정의 유일한 기준은 **최종 결과물의 품질**이다.
> 단계를 줄여서 빠르게 만드는 것보다, 단계를 늘려서라도 품질을 높이는 방향을 선택한다.

적용 예시:
- 워크플로우 단계가 많아져도 품질이 높아지면 → 단계 추가
- 에이전트를 더 써야 품질이 올라가면 → 에이전트 추가
- 검증 단계가 반복되어도 결과물이 나아지면 → 반복 허용

### 절대 기준 2: 단일 파일 SOT + 계층적 메모리 구조

> **단일 파일 SOT(Single Source of Truth) + 계층적 메모리 구조 설계 아래서, 수십 개의 에이전트가 동시에 작동해도 데이터 불일치가 발생하지 않는다.**

설계 규칙:
- **상태 집중**: 워크플로우의 모든 공유 상태는 **단일 파일**(예: `state.json`, `state.yaml`)에 집중한다. 여러 파일에 상태를 분산시키지 않는다.
- **단일 쓰기 지점**: SOT 파일에 대한 쓰기 권한은 Orchestrator(또는 지정된 단일 에이전트)만 갖는다. 다른 에이전트는 읽기 전용으로 접근하고, 자신의 결과를 별도 산출물 파일로 생성한다.
- **충돌 방지**: 복수 에이전트가 동일 파일을 동시에 수정하는 구조를 설계하지 않는다.

```
Bad:  Agent A → state.json 직접 수정
      Agent B → state.json 직접 수정  → 데이터 충돌

Good: Agent A → output-a.md 생성 → Orchestrator에 보고
      Agent B → output-b.md 생성 → Orchestrator에 보고
      Orchestrator → state.json에 병합  → 단일 쓰기 지점
```

### 절대 기준 3: 코드 변경 프로토콜 (Code Change Protocol)

> **코드를 작성·수정·추가·삭제하기 전에, 반드시 아래 3단계를 내부적으로 수행한다.**
> 이 프로토콜을 건너뛰는 것은 절대 기준 위반이다.

절대 기준 1(품질)이 "무엇을 최적화하는가"를 정의하고, 절대 기준 2(SOT)가 "데이터를 어떻게 구조화하는가"를 정의한다면, 절대 기준 3은 **"코드를 변경할 때 어떻게 행동하는가"**를 정의한다. 품질 높은 코드는 의존성·결합도·변경 파급 효과를 사전에 분석하는 엄밀한 프로세스에서 나온다.

**Step 1 — 의도 파악:**
- 사용자가 지시한 구현사항을 정확하게 파악했는가? 1-2문장으로 명확하게 설명할 수 있어야 한다.
- 변경 목적(버그 수정, 리팩토링, 성능, 기능 추가 등)과 제약(호환성 유지 여부, 사용 기술 스택 등)을 정확하게 파악했는가?

**Step 2 — 영향 범위 분석 (Ripple Effect Analysis):**

신규 코드 작성 및 기존 코드 수정이 코드베이스 전체에 가져오는 영향을 조사한다:
- **직접 의존**: 수정 대상이 정의된 함수/클래스/모듈/파일
- **호출 관계**: 이 코드를 호출하거나, 이 코드가 호출하는 다른 코드
- **구조적 관계**: 상속/구현(inheritance, interface), 합성/구성(composition), 연관/참조(association)
- **데이터 모델/스키마**: 같이 변경되어야 할 타입/필드/검증 로직
- **테스트 코드**: 단위 테스트, 통합 테스트, 스냅샷 테스트 등
- **설정/환경/빌드**: config, DI 설정, 라우팅, 의존성 주입 등
- **문서/주석/API 스펙**: 주석, README, API 문서, 타입 정의 등

"여기를 바꾸었으니, 이 변경이 어디까지 파급될 수 있는지"를 전문가 수준에서 조사한다. 결합도가 높은 부분(강결합, 변경 결합, 샷건 서저리 가능성)이 있다면 **반드시** 사전 고지하여 사용자와 협의한다.

**Step 3 — 변경 설계 (Change Plan):**
- 연관된 실제 코드를 업데이트하기 전에, 단계별 변경 계획을 제안한다:
  - 1단계: 어떤 파일/클래스/함수부터 수정할지
  - 2단계: 하위 의존성/호출자에 어떤 변경을 전파할지
  - 3단계: 테스트/문서/설정을 어떻게 맞출지
- 결합도 감소 / 응집도 증가 관점에서 더 나은 구조로의 리팩토링 기회가 보이면 함께 제안한다 (실행은 사용자 승인 후).

**비례성 규칙 — 프로토콜은 항상 수행하되, 분석 깊이는 변경의 영향 범위에 비례한다:**

| 변경 규모 | 기준 | 적용 깊이 |
|----------|------|---------|
| **경미** | 오타, 주석, 포맷팅 등 로직 무관 변경 | Step 1만 — "파급 효과 없음" 1문장 확인 후 즉시 실행 |
| **표준** | 함수/로직 변경, 파일 추가/삭제 | 전체 3단계 수행 |
| **대규모** | 아키텍처, 공개 API, cross-cutting 변경 | 전체 3단계 + **반드시** 사전 사용자 승인 |

적용 예시:

```
Bad:  "사용자가 함수 수정을 요청 → 해당 함수만 수정 → 호출자 6곳이 런타임 에러"
Good: "사용자가 함수 수정을 요청 → 호출 관계 6곳 확인 → 영향 범위 고지 → 단계별 변경 계획 제안 → 승인 후 실행"
```

**커뮤니케이션 규칙:**
- 불필요하게 장황한 이론 설명은 피하고, 실질적인 코드와 구체적 단계 위주로 설명한다.
- 중요한 설계 선택에는 간단한 이유를 덧붙인다.
- 모호한 부분이 있어도 작업을 회피하지 말고, "합리적인 가정"을 명시한 뒤 최선의 설계를 제안한다.

### 절대 기준 간 우선순위

> **절대 기준 1(품질)이 최상위이다. 절대 기준 2(SOT)와 절대 기준 3(CCP)은 품질을 보장하기 위한 동위 수단이다.**

```
절대 기준 1 (품질) — 최상위. 모든 기준의 존재 이유.
  ├── 절대 기준 2 (SOT) — 데이터 무결성 보장 수단
  └── 절대 기준 3 (CCP) — 코드 변경 품질 보장 수단
```

절대 기준 2(SOT)와 3(CCP)은 서로 다른 차원에서 작동하므로 직접 충돌 가능성은 낮다. 어느 기준이든 절대 기준 1(품질)과 충돌하면 품질이 이긴다. SOT와 CCP 모두 품질을 보장하기 위한 **수단**이지, 품질을 제약하는 **목적**이 아니다.

충돌 시나리오와 해소:
- SOT 단일 쓰기 지점이 정보 병목을 일으켜 에이전트가 오래된 데이터로 작업 → **에이전트 간 산출물 직접 참조 허용** (SOT 구조 조정)
- 품질 향상을 위한 단계 추가로 SOT 상태 복잡도 증가 → **감수** (절대 기준 1 > 2)
- 완전 독립 병렬 작업(에이전트 간 공유 상태 없음)에서 SOT가 불필요 → **SOT 경량화 허용** (판단 근거 문서화)
- CCP의 전체 분석이 사소한 변경에 과도한 오버헤드 → **비례성 규칙 적용** (경미한 변경은 Step 1만)

---

## 3. 설계 원칙

절대 기준에 종속되는 하위 원칙이다.

### P1. 정확도를 위한 데이터 정제

큰 데이터를 AI에게 그대로 전달하면 노이즈로 정확도가 하락한다.

- 각 단계에 **전처리(pre-processing)** 명시: 에이전트에게 넘기기 전 노이즈 제거
- 각 단계에 **후처리(post-processing)** 명시: 산출물을 다음 단계에 전달하기 전 정제
- 코드로 사전 계산 가능한 연관관계는 미리 처리 → AI가 판단·분석에 집중

```
Bad:  "수집된 전체 웹페이지 HTML을 에이전트에 전달"
Good: "Python script로 본문만 추출 → 핵심 텍스트만 에이전트에 전달"
```

### P2. 전문성 기반 위임 구조

각 작업을 가장 잘 수행할 수 있는 전문 에이전트에게 위임하여 품질을 극대화한다. Orchestrator는 전체 품질을 조율하고, 전문 에이전트는 각자의 영역에 깊이 집중한다.

```
Orchestrator (품질 조율 + 흐름 관리)
  ├→ Agent A: 전문 리서치 (해당 도메인 최적화)
  ├→ Agent B: 심층 분석 (분석에만 집중)
  └→ Agent C: 검증 및 품질 게이트
```

### P3. 리소스 정확성

이미지, 파일, 외부 리소스가 필요한 단계에서는 정확한 경로를 명시한다. placeholder 누락 불가.

### P4. 질문 설계 규칙

사용자에게 질문할 때:
- 최대 4개까지만
- 각 질문에 3개 정도의 선택지 제공
- 모호한 부분이 없으면 질문 없이 진행

---

## 4. 프로젝트 구조

```
AgenticWorkflow/
├── CLAUDE.md          ← Claude Code 전용 지시서
├── AGENTS.md          ← 이 파일 (모델 무관 공통 지시서)
├── README.md          ← 프로젝트 소개
├── AGENTICWORKFLOW-USER-MANUAL.md              ← 사용자 매뉴얼
├── AGENTICWORKFLOW-ARCHITECTURE-AND-PHILOSOPHY.md  ← 설계 철학 및 아키텍처 전체 조감도
├── COPYRIGHT.md          ← 저작권
├── .claude/
│   ├── settings.json          ← Hook 설정 (Setup + SessionEnd)
│   ├── commands/              ← Slash Commands
│   │   ├── install.md         (Setup Init 검증 결과 분석 — /install)
│   │   └── maintenance.md     (Setup Maintenance 건강 검진 — /maintenance)
│   ├── hooks/scripts/         ← Context Preservation System + Setup Hooks
│   │   ├── context_guard.py   (Global Hook 통합 디스패처)
│   │   ├── _context_lib.py    (공유 라이브러리 + 절삭 상수 중앙화 + sot_paths() 경로 통합 + 다단계 전환 감지 + Smart Throttling + Autopilot 상태 읽기·검증)
│   │   ├── save_context.py    (저장 엔진)
│   │   ├── restore_context.py (복원 — RLM 포인터 + 완료/Git 상태)
│   │   ├── update_work_log.py (작업 로그 누적 — 9개 도구 추적)
│   │   ├── generate_context_summary.py (증분 스냅샷 + Knowledge Archive + E5 Guard + Autopilot Decision Log 안전망)
│   │   ├── setup_init.py      (Setup Init — 인프라 건강 검증, --init 트리거)
│   │   └── setup_maintenance.py (Setup Maintenance — 주기적 건강 검진, --maintenance 트리거)
│   ├── context-snapshots/     ← 런타임 스냅샷 (gitignored)
│   └── skills/
│       ├── workflow-generator/   ← 워크플로우 설계·생성
│       │   ├── SKILL.md          (스킬 정의 + 절대 기준)
│       │   └── references/       (구현 패턴, 템플릿, 문서 분석 가이드)
│       └── doctoral-writing/     ← 박사급 학술 글쓰기
│           ├── SKILL.md          (스킬 정의 + 절대 기준)
│           └── references/       (체크리스트, 빈출 오류, 수정 사례, 분야별 가이드)
├── prompt/              ← 프롬프트 자료
│   ├── crystalize-prompt.md      (프롬프트 압축 기법)
│   ├── distill-partner.md        (에센스 추출 및 최적화)
│   └── crawling-skill-sample.md  (크롤링 스킬 샘플)
└── coding-resource/     ← 참고 자료
```

### Context Preservation System

컨텍스트 윈도우 소진, 세션 초기화, 컨텍스트 압축 시 작업 맥락이 상실되는 문제를 방지하는 자동 저장·복원 시스템이다.

**핵심 원리:**
- RLM 패턴 적용: 작업 내역을 **외부 메모리 객체**(MD 파일)로 영속화하고, 새 세션에서 포인터 기반으로 복원
- P1 원칙 준수: 트랜스크립트 파싱·통계 산출은 Python 코드가 결정론적으로 수행. AI는 의미 해석에만 집중
- 절대 기준 2 준수: SOT 파일(`state.yaml`)은 **읽기 전용**으로만 접근. 스냅샷은 별도 디렉터리(`context-snapshots/`)에 저장
- **Knowledge Archive**: 세션 간 지식 축적 — `knowledge-index.jsonl`에 세션 사실을 결정론적으로 추출·축적. Stop hook과 SessionEnd/PreCompact 모두에서 기록하여 세션의 100% 인덱싱 보장. 각 엔트리에 completion_summary(도구 성공/실패), git_summary(변경 상태), phase(세션 단계), phase_flow(다단계 전환 흐름), primary_language(주요 파일 확장자) 포함. AI가 Grep으로 프로그래밍적 탐색 (RLM 패턴)
- **Resume Protocol**: 스냅샷에 결정론적 복원 지시 포함 — 수정/참조 파일 목록, 세션 메타데이터, 완료 상태(도구 성공/실패), Git 변경 상태. 복원 품질의 바닥선 보장
- **Autopilot 런타임 강화**: Autopilot 활성 시 스냅샷에 Autopilot 상태 섹션(IMMORTAL 우선순위)을 포함하고, 세션 복원 시 실행 규칙을 컨텍스트에 주입. Stop hook이 Decision Log 누락을 감지·보완

**데이터 흐름:**

```
작업 진행 중 ─→ [PostToolUse] update_work_log.py ─→ work_log.jsonl 누적 (9개 도구 추적)
                                                     │ (토큰 75% 초과 시)
                                                     ↓
응답 완료 ────→ [Stop] generate_context_summary.py ─→ latest.md 저장 (30초 throttling)
                                                     │        + knowledge-index.jsonl 축적
                                                     │        + sessions/ 아카이빙
                                                     │        + E5 Empty Snapshot Guard
                                                     ↓
세션 종료/압축 ─→ [SessionEnd/PreCompact] save_context.py ─→ latest.md 저장
                                                     │        + knowledge-index.jsonl 축적
                                                     │        + sessions/ 아카이빙
                                                     ↓
새 세션 시작 ──→ [SessionStart] restore_context.py ───────→ 포인터+요약+완료상태+Git상태 출력
                                                     AI가 Read tool로 전체 복원
```

---

## 5. 구현 요소 매핑

워크플로우 설계 시 아래 구현 요소를 조합한다. 도구마다 명칭이 다르지만 개념은 동일하다.

| 워크플로우 요소 | 개념 | 선택 기준 |
|---------------|------|----------|
| **전문 에이전트** | 특정 영역에 집중하는 단일 에이전트 | 깊은 맥락 유지가 품질의 핵심일 때 |
| **에이전트 그룹** | 복수 에이전트가 병렬로 독립 작업 | 다관점 분석·교차 검증이 품질을 높일 때 |
| **사람 개입 지점** | 검토/승인/선택 등 사용자 인터랙션 | 자동화할 수 없는 판단이 필요할 때 |
| **자동 검증** | 품질 게이트, 포맷 검사, 보안 체크 | 반복적 검증을 자동화할 때 |
| **재사용 모듈** | 도메인 지식, 반복 패턴을 캡슐화 | 검증된 패턴을 일관되게 적용할 때 |
| **외부 연동** | API, DB, 외부 서비스 통합 | 외부 데이터/기능이 필요할 때 |
| **동적 질문 수집** | 실행 중 사용자에게 구조화된 질문으로 정보 수집 | P4 규칙 적용. 선택지가 사전 정의 불가능하고 동적 판단이 필요할 때 |
| **작업 할당·추적** | 에이전트 그룹 사용 시 Task 생성·할당·의존성·진행 추적 | SOT를 대체하지 않음. 에이전트 간 작업 조율이 필요할 때 |

> **에이전트 선택의 유일한 기준은 "어떤 구조가 최종 결과물의 품질을 가장 높이는가"이다.**
> 병렬 처리가 빠르다는 이유로 에이전트 그룹을 선택하지 않는다.
> 토큰을 적게 쓴다는 이유로 단일 에이전트를 선택하지 않는다.

#### 전문 에이전트 vs 에이전트 그룹 — 품질 판단 매트릭스

5개 품질 요인으로 구조를 결정한다. "빠르니까" "싸니까"는 판단 기준이 아니다:

| 품질 요인 | 전문 에이전트 우위 | 에이전트 그룹 우위 | 판단 질문 |
|----------|-----------------|-----------------|----------|
| **맥락 깊이** | 선행 단계 결과를 깊이 참조해야 할 때 | 각 작업이 독립적 전문성을 요구할 때 | "이전 단계의 뉘앙스를 잃으면 품질이 떨어지는가?" |
| **교차 검증** | 단일 관점이 일관성을 보장할 때 | 다관점 분석이 편향을 제거할 때 | "다른 시각이 결과의 신뢰도를 높이는가?" |
| **산출물 일관성** | 문체/톤의 통일이 중요할 때 | 각 산출물이 독립적으로 완결될 때 | "산출물 간 톤 불일치가 품질 문제인가?" |
| **에러 격리** | 전체 맥락에서 에러를 잡아야 할 때 | 개별 작업 실패가 다른 작업에 영향 없어야 할 때 | "하나의 실패가 전체를 오염시키는가?" |
| **정보 전달 손실** | 파일 전달 시 뉘앙스 유실 위험이 클 때 | 구조화된 데이터만 전달해도 충분할 때 | "맥락 요약으로 전달하면 정보 손실이 발생하는가?" |

**판단 규칙:**
1. 5개 요인 중 전문 에이전트 우위가 3개 이상이면 → **전문 에이전트**
2. 에이전트 그룹 우위가 3개 이상이면 → **에이전트 그룹**
3. 동점(2:2 + 판단 불가 1개)이면 → **맥락 깊이** 요인이 tiebreaker (맥락 유지가 일반적으로 더 안전)
4. 확신이 없으면 → **전문 에이전트** (안전한 기본값 — 맥락 유지 보장)

#### 모델 수준 선택 — 품질 기반 판단

| 모델 수준 | 선택 기준 | 적합 작업 |
|----------|----------|----------|
| **최고 수준** | 핵심 작업 — 최종 품질에 직접 영향 | 핵심 분석, 최종 글쓰기, 전략 판단, 코드 아키텍처 |
| **안정 수준** | 반복 작업 — 패턴이 확립된 작업 | 데이터 수집, 포맷 변환, 표준화된 분류 |
| **보조 수준** | 단순 작업 — 판단이 최소인 작업 | 포맷 검증, 간단한 필터링, 라벨 추출 |

**판단 절차:**
1. 해당 작업이 최종 결과물의 품질에 얼마나 직접적으로 영향을 미치는가?
2. 모델 수준 간 품질 차이가 유의미한가?
   - 유의미하면 → 상위 모델
   - 유의미하지 않으면 → 하위 모델 허용
3. 확신이 없으면 → **상위 모델** (품질 보장 원칙 — 절대 기준 1)

### 5.1 Autopilot Mode

워크플로우 실행 시 **사람 개입 지점(human-in-the-loop)**을 자동 승인하여 무중단 실행하는 모드.

**핵심 원칙:**
- Autopilot은 사람 개입 지점의 **자동 승인**만 수행한다
- 모든 워크플로우 단계는 **완전히 실행**한다 — 단계 생략 금지
- 모든 산출물은 **완전한 품질**로 생성한다 — 축약 금지
- 자동 검증(Hook exit code 2)은 Autopilot에서도 **그대로 차단**한다

**대상 구분:**

| 메커니즘 | Autopilot 동작 | 근거 |
|---------|---------------|------|
| 사람 개입 지점 `(human)` | 자동 승인 — 품질 극대화 기본값 선택 | 사람의 판단을 AI가 대행 |
| 동적 질문 수집 | 자동 응답 — 품질 극대화 옵션 선택 | 사람의 선택을 AI가 대행 |
| 자동 검증 `(hook)` exit code 2 | **변경 없음 — 그대로 차단** | 결정론적 검증이므로 사람 판단 대행 대상 아님 |

**Anti-Pattern:**
1. Autopilot ≠ 단계 생략: 모든 단계를 순차적으로 완전히 실행한다
2. Autopilot ≠ 축약 출력: 모든 에이전트는 사람이 검토하는 것과 동일한 품질·분량의 산출물을 생성한다

**Anti-Skip Guard (런타임 검증):**

각 단계 완료 시 Orchestrator가 수행하는 결정론적 검증:
1. 산출물 파일이 SOT `outputs`에 경로로 기록되었는가
2. 해당 파일이 디스크에 존재하는가
3. 파일 크기가 최소 100 bytes 이상인가 (의미 있는 콘텐츠 보장)

> Claude Code의 Hook 시스템에서는 `_context_lib.py`의 `validate_step_output()` 함수가 이 검증을 결정론적으로 수행한다. 다른 도구에서는 동등한 파일 검증 로직을 구현한다.

**SOT 기록:**
```yaml
workflow:
  name: "my-workflow"
  current_step: 3
  status: "running"
  outputs:
    step-1: "research/raw-contents.md"
    step-2: "analysis/insights-list.md"
  autopilot:
    enabled: true
    activated_at: "ISO-8601"
    auto_approved_steps: [3, 6]
```

- `autopilot.enabled`: Boolean — Autopilot 활성화 여부
- `autopilot.auto_approved_steps`: 자동 승인된 단계 번호 목록
- `outputs`: 단계별 산출물 경로 — Anti-Skip Guard의 검증 대상
- 자동 승인 결정은 별도 로그 파일(`autopilot-logs/step-N-decision.md`)에 기록 (투명성 보장)
- Decision Log 표준 템플릿: Claude Code의 `references/autopilot-decision-template.md` 참조

**런타임 강화 (Claude Code 구현):**

| 계층 | 메커니즘 | 강화 내용 |
|------|---------|----------|
| **Hook** | SessionStart 컨텍스트 주입 | 세션 시작/복원 시 Autopilot 실행 규칙 + 이전 단계 검증 결과를 프롬프트에 주입 |
| **Hook** | 스냅샷 Autopilot 섹션 | 세션 경계에서 Autopilot 상태를 IMMORTAL 우선순위로 보존 |
| **Hook** | Stop Decision Log 안전망 | 자동 승인 패턴 감지 → Decision Log 누락 시 보완 생성 |
| **Hook** | PostToolUse 진행 추적 | work_log에 `autopilot_step` 필드로 단계 진행 기록 |
| **프롬프트** | Execution Checklist | CLAUDE.md에 정의된 각 단계 시작/실행/완료 필수 행동 목록 |

> Hook 계층은 SOT를 **읽기 전용**으로만 접근한다 (절대 기준 2 준수).

**활성화:** 기본값은 비활성(interactive). 워크플로우 Overview에 `Autopilot: enabled` 명시 또는 실행 시 사용자 지시로 활성화. 실행 중 토글 가능.

---

## 6. 스킬 체계

### workflow-generator

워크플로우 정의 파일(`workflow.md`)을 설계·생성하는 스킬.

- **트리거**: "워크플로우 만들어줘", "자동화 파이프라인 설계", "작업 흐름 정의"
- **진입점**: `.claude/skills/workflow-generator/SKILL.md`
- **두 가지 케이스**: (1) 아이디어만 있는 경우 → 대화형 질문, (2) 설명 문서가 있는 경우 → 문서 분석 우선

### doctoral-writing

박사급 학위 논문의 학문적 엄밀성과 명료성을 갖춘 글쓰기 스킬.

- **트리거**: "논문 스타일로 써줘", "학술적 글쓰기", "논문 문장 다듬기"
- **진입점**: `.claude/skills/doctoral-writing/SKILL.md`
- **핵심 원칙**: 명료성, 간결성, 학술적 엄밀성, 논리적 흐름

---

## 7. 스킬 개발 규칙

새로운 스킬을 만들거나 기존 스킬을 수정할 때:

1. **모든 절대 기준을 반드시 포함** — 해당 도메인에 맞게 맥락화하여 적용 (코드 변경이 아닌 도메인의 경우 절대 기준 3은 N/A 가능)
2. **파일 간 역할 분담** — 스킬 정의(WHY), 참조 자료(WHAT/HOW/VERIFY)
3. **절대 기준 간 충돌 시나리오를 구체적으로 명시** — 추상적 규칙이 아닌 실전 판단 기준
4. **수정 후 반드시 성찰** — 문구만 넣지 않고, 기존 내용과 충돌 여부를 점검

---

## 8. 언어 및 스타일

- **콘텐츠 언어**: 한국어
- **기술 용어**: 영어 유지 (SOT, Agent, Orchestrator, Hooks 등)
- **시각화**: Mermaid 다이어그램 선호
- **서술 깊이**: 간략 요약보다 포괄적·데이터 기반 서술 선호
- **코드 주석**: 한국어

---

## 9. 범용 시스템 프롬프트 체계 (Hub-and-Spoke)

이 프로젝트는 **어떤 AI CLI 도구를 사용하든** 동일한 방법론이 자동으로 적용되도록 설계되었다.

### 아키텍처

```
                AGENTS.md (Hub — 방법론 SOT)
               /    |    |    \    \     \
          CLAUDE  GEMINI .cursor  .github/
          .md     .md    /rules   copilot-
                         (Spoke)  instructions.md
```

- **Hub (AGENTS.md)**: 절대 기준, 설계 원칙, 워크플로우 구조의 유일한 정의 지점
- **Spoke (도구별 파일)**: Hub를 참조하면서 해당 도구의 고유 기능에 맞는 구현 매핑을 제공

### 도구별 파일 매핑

| AI CLI 도구 | 시스템 프롬프트 파일 | 자동 읽기 | AGENTS.md 인식 |
|------------|-------------------|----------|---------------|
| **Claude Code** | `CLAUDE.md` | Yes | 별도 파일 |
| **Gemini CLI** | `GEMINI.md` | Yes | 설정으로 추가 로드 |
| **Codex CLI** | `AGENTS.md` (직접) | Yes | 네이티브 |
| **Copilot CLI** | `.github/copilot-instructions.md` | Yes | 자동 인식 |
| **Cursor** | `.cursor/rules/agenticworkflow.mdc` | Yes (alwaysApply) | 인식 |
| **Aider** | `.aider.conf.yml` → `AGENTS.md` 로드 | 설정 필요 | 설정으로 로드 |

### Spoke 파일 원칙

1. **절대 기준 인라인 + 상세 참조**: 각 Spoke는 절대 기준의 핵심 정의(1~2문장)를 인라인으로 포함하고, 상세 내용은 `AGENTS.md §2` 참조로 위임한다.
2. **도구별 구현 매핑**: 해당 도구의 고유 기능(Hook, Agent, Plugin 등)과 AgenticWorkflow 개념의 대응을 명시한다.
3. **컨텍스트 보존 대안**: Claude Code의 Context Preservation System을 사용할 수 없는 도구에서는 해당 도구에서 가능한 대안을 안내한다.

### 충돌 해소

> **AGENTS.md의 절대 기준이 모든 Spoke보다 우선한다.** 도구 종속적 구현이 원칙과 충돌하면 원칙이 이긴다.

### 절대 기준 변경 시 동기화

AGENTS.md의 절대 기준이 변경되면, 모든 Spoke 파일의 인라인 복제도 동기화해야 한다:
- `CLAUDE.md`, `GEMINI.md` — 직접 수정
- `.cursor/rules/` — 인라인 부분 수정
- `.github/copilot-instructions.md` — 인라인 부분 수정
